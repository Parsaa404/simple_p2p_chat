# security/diffie_hellman.py
# This module will handle Diffie-Hellman key exchange.

from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.backends import default_backend

# Standard pre-defined DH parameters (use a well-known group for security)
# Using a 2048-bit MODP Group (RFC 3526, Group 14)
# For real applications, generating these parameters can be time-consuming,
# so using standard ones is common and recommended.
# However, the cryptography library's DH implementation generates parameters on the fly if not provided.
# For simplicity and to ensure both sides use the same params without pre-sharing them beyond code,
# we can generate them once or use library's ability to generate.

# For this implementation, we will let the `cryptography` library generate parameters.
# A peer initiating an exchange will generate parameters and its public key.
# The responding peer will use these parameters to generate its own keys.

class DHExchange:
    def __init__(self):
        self.private_key = None
        self.public_key_bytes = None
        self.parameters = None
        self.shared_secret = None

    def generate_parameters_and_keys(self):
        """
        Generates DH parameters and the first party's private/public keys.
        This is typically called by the peer initiating the key exchange.
        """
        # Generate parameters. This can be slow.
        # For faster setup, pre-generated parameters (dh.generate_private_key(parameters=...)) are better.
        # However, to avoid pre-sharing parameters in code for now, let's generate.
        # A more robust solution would involve one side generating and sending parameters.
        # For now, we assume parameters are implicitly agreed upon by using this class.
        # A better approach for two peers:
        # Peer A: generates parameters, then private_key_A using these params. Sends params and public_key_A.
        # Peer B: receives params. Generates private_key_B using received params. Sends public_key_B.
        # For now, this method is simplified: it generates parameters and a key pair.
        # The `parameters` object itself isn't directly sent in this simplified model,
        # but the public key implies them if both sides use `generate_private_key` without pre-set params.
        # This is NOT ideal for interoperability if not handled carefully.
        # Let's refine this: the initiator generates params and its key.

        self.parameters = dh.generate_parameters(generator=2, key_size=2048, backend=default_backend())
        self.private_key = self.parameters.generate_private_key()
        self.public_key_bytes = self.private_key.public_key().public_bytes(
            encoding=dh.serialization.Encoding.PEM,
            format=dh.serialization.PublicFormat.SubjectPublicKeyInfo
        )
        return self.parameters, self.public_key_bytes

    def generate_keys_with_parameters(self, peer_parameters_bytes: bytes):
        """
        Generates DH private/public keys using parameters received from the peer.
        This is typically called by the responding peer.
        """
        try:
            self.parameters = dh.serialization.load_pem_parameters(peer_parameters_bytes, default_backend())
            self.private_key = self.parameters.generate_private_key()
            self.public_key_bytes = self.private_key.public_key().public_bytes(
                encoding=dh.serialization.Encoding.PEM,
                format=dh.serialization.PublicFormat.SubjectPublicKeyInfo
            )
            return self.public_key_bytes
        except Exception as e:
            print(f"Error generating keys with peer parameters: {e}")
            return None

    def get_public_key_bytes(self):
        """Returns the public key as PEM bytes."""
        if not self.public_key_bytes:
            # This might happen if generate_parameters_and_keys or generate_keys_with_parameters wasn't called
            # Or if a different path was taken. Let's assume keys are generated by one of the above.
            if self.private_key:
                 self.public_key_bytes = self.private_key.public_key().public_bytes(
                    encoding=dh.serialization.Encoding.PEM,
                    format=dh.serialization.PublicFormat.SubjectPublicKeyInfo
                )
            else:
                raise ValueError("Private key not generated. Cannot get public key.")
        return self.public_key_bytes

    def calculate_shared_secret(self, peer_public_key_bytes: bytes):
        """
        Calculates the shared secret using the peer's public key.
        The derived key should be passed through a KDF (Key Derivation Function).
        """
        if not self.private_key:
            raise ValueError("Private key not generated. Cannot calculate shared secret.")

        try:
            peer_public_key = dh.serialization.load_pem_public_key(peer_public_key_bytes, default_backend())
        except Exception as e:
            print(f"Error loading peer public key: {e}")
            return None

        shared_key_material = self.private_key.exchange(peer_public_key)

        # Derive a fixed-size key from the shared secret using HKDF
        # Using SHA256 as the hash algorithm for HKDF
        # The 'info' parameter can be context-specific, like b'session_encryption_key'
        derived_key = HKDF(
            algorithm=hashes.SHA256(),
            length=32,  # For Fernet, we need a 32-byte key
            salt=None,  # Optional salt, can be set to a fixed random value or derived
            info=b'p2p_chat_session_key',
            backend=default_backend()
        ).derive(shared_key_material)

        self.shared_secret = derived_key # This is the key to be used for symmetric encryption
        return self.shared_secret

    def get_parameters_bytes(self):
        """Serializes DH parameters to PEM bytes."""
        if not self.parameters:
            raise ValueError("Parameters not generated or loaded.")
        return self.parameters.parameter_bytes(
            encoding=dh.serialization.Encoding.PEM,
            format=dh.serialization.ParameterFormat.PKCS3
        )

# Example Usage (for testing this module directly)
if __name__ == '__main__':
    # Peer A (initiator)
    peer_a = DHExchange()
    # Peer A generates parameters and its key pair
    # In a real scenario, Peer A would send `params_bytes_a` and `pub_key_bytes_a` to Peer B
    params_a, pub_key_bytes_a = peer_a.generate_parameters_and_keys()
    params_bytes_a = peer_a.get_parameters_bytes() # Serialize params for sending

    print("Peer A generated parameters and public key.")
    # print(f"Peer A Parameters (PEM):\n{params_bytes_a.decode()}")
    # print(f"Peer A Public Key (PEM):\n{pub_key_bytes_a.decode()}")

    # Peer B (responder)
    peer_b = DHExchange()
    # Peer B receives `params_bytes_a` from Peer A and generates its key pair
    pub_key_bytes_b = peer_b.generate_keys_with_parameters(params_bytes_a)
    if not pub_key_bytes_b:
        print("Peer B failed to generate keys.")
        exit()

    print("Peer B generated public key using Peer A's parameters.")
    # print(f"Peer B Public Key (PEM):\n{pub_key_bytes_b.decode()}")

    # Exchange public keys:
    # Peer A receives `pub_key_bytes_b` from Peer B
    # Peer B receives `pub_key_bytes_a` from Peer A (already has it in this simulation)

    # Both peers calculate the shared secret
    shared_secret_a = peer_a.calculate_shared_secret(pub_key_bytes_b)
    shared_secret_b = peer_b.calculate_shared_secret(pub_key_bytes_a)

    if shared_secret_a and shared_secret_b:
        print(f"\nShared Secret (Peer A): {shared_secret_a.hex()}")
        print(f"Shared Secret (Peer B): {shared_secret_b.hex()}")

        if shared_secret_a == shared_secret_b:
            print("\nSuccess! Both peers derived the same shared secret.")
            print("This secret can now be used for symmetric encryption (e.g., with Fernet).")
        else:
            print("\nError! Shared secrets do not match.")
    else:
        print("\nError! Could not derive shared secrets.")

    print("\n--- Test: Initiator does not send parameters separately, responder uses pub key params ---")
    # This scenario is more complex as public key PEM for DH doesn't always embed all params needed to init
    # the DH object on the other side without `load_pem_parameters` first.
    # The `cryptography` library's `DHParameters` are needed.
    # The above flow (sending parameters explicitly) is more robust.

    # Let's re-verify the flow:
    # 1. Initiator (A) generates parameters (P) and its keypair (privA, pubA).
    #    Sends P (serialized) and pubA (serialized) to Responder (B).
    # 2. Responder (B) deserializes P. Generates its keypair (privB, pubB) using P.
    #    Sends pubB (serialized) to A.
    # 3. A computes shared_secret using privA and pubB.
    # 4. B computes shared_secret using privB and pubA.
    # This is the correct and robust way. The example code follows this.

    # Consider a case where parameters are fixed (e.g. a standard group known by both)
    # In this case, no need to send parameters, only public keys.
    # `dh.generate_private_key(parameters=predefined_parameters_object)`
    # This would simplify the exchange if a common group is agreed upon.
    # For now, explicit parameter exchange is implemented.

    # Test key derivation length
    assert len(shared_secret_a) == 32, "Derived key length is not 32 bytes for Fernet."
    print(f"Derived key length: {len(shared_secret_a)} bytes.")
